## 字符串对象的方法

字符串对象的方法之中，有4种与正则对象有关。

- `match()`：返回一个数组，成员是所有匹配的子字符串。
- `search()`：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。
- `replace()`：按照给定的正则表达式进行替换，返回替换后的字符串。
- `split()`：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。

下面逐一介绍。

### String.prototype.match()

字符串对象的`match`方法对字符串进行正则匹配，返回匹配结果。

```
var s = '_x_x';
var r1 = /x/;
var r2 = /y/;

s.match(r1) // ["x"]
s.match(r2) // null

```

从上面代码可以看到，字符串的`match`方法与正则对象的`exec`方法非常类似：匹配成功返回一个数组，匹配失败返回`null`。

如果正则表达式带有`g`修饰符，则该方法与正则对象的`exec`方法行为不同，会一次性返回所有匹配成功的结果。

```
var s = 'abba';
var r = /a/g;

s.match(r) // ["a", "a"]
r.exec(s) // ["a"]

```

设置正则表达式的`lastIndex`属性，对`match`方法无效，匹配总是从字符串的第一个字符开始。

```
var r = /a|b/g;
r.lastIndex = 7;
'xaxb'.match(r) // ['a', 'b']
r.lastIndex // 0

```

上面代码表示，设置`lastIndex`属性是无效的。

### String.prototype.search()

字符串对象的`search`方法，返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回`-1`。

```
'_x_x'.search(/x/)
// 1

```

上面代码中，第一个匹配结果出现在字符串的`1`号位置。

该方法会忽略`g`修饰符。

```
var r = /x/g;
r.lastIndex = 2; // 无效
'_x_x'.search(r) // 1

```

上面代码中，正则表达式使用`g`修饰符之后，使用`lastIndex`属性指定开始匹配的位置，结果无效，还是从字符串的第一个字符开始匹配。

### String.prototype.replace()

字符串对象的`replace`方法可以替换匹配的值。它接受两个参数，第一个是搜索模式，第二个是替换的内容。

```
str.replace(search, replacement)

```

搜索模式如果不加g修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。

```
'aaa'.replace('a', 'b') // "baa"
'aaa'.replace(/a/, 'b') // "baa"
'aaa'.replace(/a/g, 'b') // "bbb"

```

上面代码中，最后一个正则表达式使用了`g`修饰符，导致所有的`b`都被替换掉了。

`replace`方法的一个应用，就是消除字符串首尾两端的空格。

```
var str = '  #id div.class  ';

str.replace(/^\s+|\s+$/g, '')
// "#id div.class"

```

replace方法的第二个参数可以使用美元符号$，用来指代所替换的内容。

- `$&` 指代匹配的子字符串。
- `$`` 指代匹配结果前面的文本。
- `$'` 指代匹配结果后面的文本。
- `$n` 指代匹配成功的第`n`组内容，`n`是从1开始的自然数。
- `$$` 指代美元符号`$`。

```
'hello world'.replace(/(\w+)\s(\w+)/, '$2 $1')
// "world hello"

'abc'.replace('b', '[$`-$&-$\']')
// "a[a-b-c]c"

```

`replace`方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值。

```
'3 and 5'.replace(/[0-9]+/g, function(match){
  return 2 * match;
})
// "6 and 10"

var a = 'The quick brown fox jumped over the lazy dog.';
var pattern = /quick|brown|lazy/ig;

a.replace(pattern, function replacer(match) {
  return match.toUpperCase();
});
// The QUICK BROWN fox jumped over the LAZY dog.

```

作为`replace`方法第二个参数的替换函数，可以接受多个参数。第一个参数是捕捉到的内容，第二个参数是捕捉到的组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置（比如从第五个位置开始），最后一个参数是原字符串。下面是一个网页模板替换的例子。

```
var prices = {
  'pr_1': '$1.99',
  'pr_2': '$9.99',
  'pr_3': '$5.00'
};

var template = '/* ... */'; // 这里可以放网页模块字符串

template.replace(
  /(<span id=")(.*?)(">)(<\/span>)/g,
  function(match, $1, $2, $3, $4){
    return $1 + $2 + $3 + prices[$2] + $4;
  }
);

```

上面代码的捕捉模式中，有四个括号，所以会产生四个组匹配，在匹配函数中用`$1`到`$4`表示。匹配函数的作用是将价格插入模板中。

### String.prototype.split()

字符串对象的`split`方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。

```
str.split(separator, [limit])

```

该方法接受两个参数，第一个参数是分隔规则，第二个参数是返回数组的最大成员数。

```
// 非正则分隔
'a,  b,c, d'.split(',')
// [ 'a', '  b', 'c', ' d' ]

// 正则分隔，去除多余的空格
'a,  b,c, d'.split(/, */)
// [ 'a', 'b', 'c', 'd' ]

// 指定返回数组的最大成员
'a,  b,c, d'.split(/, */, 2)
[ 'a', 'b' ]

```

上面代码使用正则表达式，去除了子字符串的逗号后面的空格。

```
// 例一
'aaa*a*'.split(/a*/)
// [ '', '*', '*' ]

// 例二
'aaa**a*'.split(/a*/)
// ["", "*", "*", "*"]

```

上面代码的分割规则是0次或多次的`a`，由于正则默认是贪婪匹配，所以例一的第一个分隔符是`aaa`，第二个分割符是`a`，将字符串分成三个部分，包含开始处的空字符串。例二的第一个分隔符是`aaa`，第二个分隔符是0个`a`（即空字符），第三个分隔符是`a`，所以将字符串分成四个部分。

如果正则表达式带有括号，则括号匹配的部分也会作为数组成员返回。

```
'aaa*a*'.split(/(a*)/)
// [ '', 'aaa', '*', 'a', '*' ]

```

上面代码的正则表达式使用了括号，第一个组匹配是“aaa”，第二个组匹配是“a”，它们都作为数组成员返回。

# regExp匹配规则

## 字面量字符和元字符

### 点字符

点字符（`.`）匹配除回车（`\r`）、换行(`\n`) 、行分隔符（`\u2028`）和段分隔符（`\u2029`）以外的所有字符。

```
/c.t/
```

上面代码中，`c.t`匹配`c`和`t`之间包含任意一个字符的情况，只要这三个字符在同一行，比如`cat`、`c2t`、`c-t`等等，但是不匹配`coot`。

## 位置字符

位置字符用来提示字符所处的位置，主要有两个字符。

- `^` 表示字符串的开始位置
- `$` 表示字符串的结束位置

```
// test必须出现在开始位置
/^test/.test('test123') // true

// test必须出现在结束位置
/test$/.test('new test') // true

// 从开始位置到结束位置只有test
/^test$/.test('test') // true
/^test$/.test('test test') // false
```

### 选择符

竖线符号（`|`）在正则表达式中表示“或关系”（OR），即`cat|dog`表示匹配`cat`或`dog`。

```
/11|22/.test('911') // true
```

## 转义符

正则表达式中那些有特殊含义的字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配加号，就要写成`\+`。

```
/1+1/.test('1+1')
// false

/1\+1/.test('1+1')
// true
```

正则模式中，需要用斜杠转义的，一共有12个字符：`^`、`.`、`[`、`$`、`(`、`)`、`|`、`*`、`+`、`?`、`{`和`\\`。需要特别注意的是，如果使用`RegExp`方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。

```
(new RegExp('1\+1')).test('1+1')
// false

(new RegExp('1\\+1')).test('1+1')
// true
```

## 特殊字符

正则表达式对一些不能打印的特殊字符，提供了表达方法。

```
\cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。
[\b] 匹配退格键(U+0008)，不要与\b混淆。
\n 匹配换行键。
\r 匹配回车键。
\t 匹配制表符tab（U+0009）。
\v 匹配垂直制表符（U+000B）。
\f 匹配换页符（U+000C）。
\0 匹配null字符（U+0000）。
\xhh 匹配一个以两位十六进制数（\x00-\xFF）表示的字符。
\uhhhh 匹配一个以四位十六进制数（\u0000-\uFFFF）表示的unicode字符。
```

## 字符类

字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如`[xyz]` 表示`x`、`y`、`z`之中任选一个匹配。

```
/[abc]/.test('hello world') // false
/[abc]/.test('apple') // true
```

有两个字符在字符类中有特殊含义。

1. 脱字符(^)

   如果方括号内的第一个字符是`[^]`，则表示除了字符类之中的字符，其他字符都可以匹配。比如，`[^xyz]`表示除了`x`、`y`、`z`之外都可以匹配。

   ```
   /[^abc]/.test('hello world') // true
   /[^abc]/.test('bbc') // false
   ```

   如果方括号内没有其他字符，即只有`[^]`，就表示匹配一切字符，其中包括换行符，而点号（`.`）是不包括换行符的。

   ```
   var s = 'Please yes\nmake my day!';

   s.match(/yes.*day/) // null
   s.match(/yes[^]*day/) // [ 'yes\nmake my day']
   ```

   >注意，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。

2. 连字符(-)

   某些情况下，对于连续序列的字符，连字符（`-`）用来提供简写形式，表示字符的连续范围。比如，`[abc]`可以写成`[a-c]`，`[0123456789]`可以写成`[0-9]`，同理`[A-Z]`表示26个大写字母。

   ```
   /a-z/.test('b') // false
   /[a-z]/.test('b') // true
   ```

   ## 预定义模式

   预定义模式指的是某些常见模式的简写方式。

   ```
   \d 匹配0-9之间的任一数字，相当于[0-9]。
   \D 匹配所有0-9以外的字符，相当于[^0-9]。
   \w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。
   \W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。
   \s 匹配空格（包括换行符、制表符、空格符、断行符等），相等于[\t\r\n\v\f]。
   \S 匹配非空格的字符，相当于[^\t\r\n\v\f]。
   \b 匹配词的边界。
   \B 匹配非词边界，即在词的内部。
   ```

   ```
   // \s的例子
   /\s\w*/.exec('hello world') // [" world"]

   // \b的例子,\b表示词的边界，所以“world”的词首必须独立（词尾是否独立未指定），才会匹配。
   /\bworld/.test('hello world') // true
   /\bworld/.test('hello-world') // true
   /\bworld/.test('helloworld') // false

   // \B的例子
   /\Bworld/.test('hello-world') // false
   /\Bworld/.test('helloworld') // true
   ```

   ## 重复类

   模式的精确匹配次数，使用大括号（`{}`）表示。`{n}`表示恰好重复n次，`{n,}`表示至少重复n次，`{n,m}`表示重复不少于n次，不多于m次。

   ```
   /lo{2}k/.test('look') // true
   /lo{2, 5}k/.test('looook') // true
   ```

   ## 量词符

   量词符用来设定某个模式出现的次数。

   -  ? 问号表示某个模式出现0次或1次，等同于{0,1}
   -  `*` 星号表示某个模式出现0次或多次，等同于{0,}
   -  +加号表示某个模式出现1次或多次，等同于{1,}

   ## 贪婪模式

   上面的三个量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。

   ```
   var s = 'aaa';
   s.match(/a+/) // ["aaa"]
   ```

   如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。

   ```
   var s = 'aaa';
   s.match(/a+?/) // ["a"]
   ```

   这时就改为非贪婪模式，一旦条件满足，就不再往下匹配。

   - `*?`：表示某个模式出现0次或多次，匹配时采用非贪婪模式。
   - `+?`：表示某个模式出现1次或多次，匹配时采用非贪婪模式。

   ## 修饰符

   修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。

   修饰符可以单个使用，也可以多个一起使用。

   ```
   // 单个修饰符
   var regex = /test/i;

   // 多个修饰符
   var regex = /test/ig;
   ```

   - g修饰符

   默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。`g`修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。

   - i修饰符

   默认情况下，正则对象区分字母的大小写，加上`i`修饰符以后表示忽略大小写（ignorecase）。

   - m修饰符

   `m`修饰符表示多行模式（multiline），会修改`^`和`$`的行为。默认情况下（即不加`m`修饰符时），`^`和`$`匹配字符串的开始处和结尾处，加上`m`修饰符以后，`^`和`$`还会匹配行首和行尾，即`^`和`$`会识别换行符（`\n`）

   ```
   /world$/.test('hello world\n') // false
   /world$/m.test('hello world\n') // true
   /^b/m.test('a\nb') // true
   ```

   ## 组匹配

   正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。

   ```
   /fred+/.test('fredd') // true
   /(fred)+/.test('fredfred') // true
   ```

   上面代码中，第一个模式没有括号，结果`+`只表示重复字母`d`，第二个模式有括号，结果`+`就表示匹配“fred”这个词。

   下面是另外一个分组捕获的例子。

   ```
   var m = 'abcabc'.match(/(.)b(.)/);
   m
   // ['abc', 'a', 'c']
   ```

   上面代码中，正则表达式`/(.)b(.)/`一共使用两个括号，第一个括号捕获`a`，第二个括号捕获`c`。

   注意，使用组匹配时，不宜同时使用`g`修饰符，否则`match`方法不会捕获分组的内容。

   ```
   var m = 'abcabc'.match(/(.)b(.)/g);
   m
   // ['abc', 'abc']
   ```

   上面代码使用带`g`修饰符的正则表达式，结果`match`方法只捕获了匹配整个表达式的部分。

   在正则表达式内部，可以用`\n`引用括号匹配的内容，`n`是从1开始的自然数，表示对应顺序的括号。

   ```
   /(.)b(.)\1b\2/.test("abcabc")
   // true
   ```

   上面的代码中，`\1`表示前一个括号匹配的内容（即“a”），`\2`表示第二个括号匹配的内容（即“b”）。

   下面是另外一个例子。

   ```
   /y(..)(.)\2\1/.test('yabccab') // true
   ```

   括号还可以嵌套。

   ```
   /y((..)\2)\1/.test('yabababab') // true
   ```

   上面代码中，`\1`指向外层括号，`\2`指向内层括号。

   组匹配非常有用，下面是一个匹配网页标签的例子。

   ```
   var tagName = /<([^>]+)>[^<]*<\/\1>/;

   tagName.exec("<b>bold</b>")[1]
   // 'b'
   ```

   ### 非捕获组

   `(?:x)`称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。

   非捕获组的作用请考虑这样一个场景，假定需要匹配`foo`或者`foofoo`，正则表达式就应该写成`/(foo){1, 2}/`，但是这样会占用一个组匹配。这时，就可以使用非捕获组，将正则表达式改为`/(?:foo){1, 2}/`，它的作用与前一个正则是一样的，但是不会单独输出括号内部的内容。

   ```
   var m = 'abc'.match(/(?:.)b(.)/);
   m // ["abc", "c"]
   ```

   下面是用来分解网址的正则表达式。

   ```
   // 正常匹配
   var url = /(http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/;

   url.exec('http://google.com/');
   // ["http://google.com/", "http", "google.com", "/"]

   // 非捕获组匹配
   var url = /(?:http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/;

   url.exec('http://google.com/');
   // ["http://google.com/", "google.com", "/"]
   ```

   ### 先行断言

   `x(?=y)`称为先行断言（Positive look-ahead），`x`只有在`y`前面才匹配，`y`不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成`/\d+(?=%)/`。

   “先行断言”中，括号里的部分是不会返回的。

   ```
   var m = 'abc'.match(/b(?=c)/);
   m // ["b"]
   ```

   ### 先行否定断言

   `x(?!y)`称为先行否定断言（Negative look-ahead），`x`只有不在`y`前面才匹配，`y`不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成`/\d+(?!%)/`。

   ```
   /\d+(?!\.)/.exec('3.14')
   // ["14"]
   ```

   上面代码中，正则表达式指定，只有不在小数点前面的数字才会被匹配，因此返回的结果就是`14`。

   “先行否定断言”中，括号里的部分是不会返回的。

