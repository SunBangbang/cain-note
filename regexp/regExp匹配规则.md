# regExp匹配规则

## 字面量字符和元字符

### 点字符

点字符（`.`）匹配除回车（`\r`）、换行(`\n`) 、行分隔符（`\u2028`）和段分隔符（`\u2029`）以外的所有字符。

```
/c.t/
```

上面代码中，`c.t`匹配`c`和`t`之间包含任意一个字符的情况，只要这三个字符在同一行，比如`cat`、`c2t`、`c-t`等等，但是不匹配`coot`。

## 位置字符

位置字符用来提示字符所处的位置，主要有两个字符。

- `^` 表示字符串的开始位置
- `$` 表示字符串的结束位置

```
// test必须出现在开始位置
/^test/.test('test123') // true

// test必须出现在结束位置
/test$/.test('new test') // true

// 从开始位置到结束位置只有test
/^test$/.test('test') // true
/^test$/.test('test test') // false
```

### 选择符

竖线符号（`|`）在正则表达式中表示“或关系”（OR），即`cat|dog`表示匹配`cat`或`dog`。

```
/11|22/.test('911') // true
```

## 转义符

正则表达式中那些有特殊含义的字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配加号，就要写成`\+`。

```
/1+1/.test('1+1')
// false

/1\+1/.test('1+1')
// true
```

正则模式中，需要用斜杠转义的，一共有12个字符：`^`、`.`、`[`、`$`、`(`、`)`、`|`、`*`、`+`、`?`、`{`和`\\`。需要特别注意的是，如果使用`RegExp`方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。

```
(new RegExp('1\+1')).test('1+1')
// false

(new RegExp('1\\+1')).test('1+1')
// true
```

## 特殊字符

正则表达式对一些不能打印的特殊字符，提供了表达方法。

```
\cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。
[\b] 匹配退格键(U+0008)，不要与\b混淆。
\n 匹配换行键。
\r 匹配回车键。
\t 匹配制表符tab（U+0009）。
\v 匹配垂直制表符（U+000B）。
\f 匹配换页符（U+000C）。
\0 匹配null字符（U+0000）。
\xhh 匹配一个以两位十六进制数（\x00-\xFF）表示的字符。
\uhhhh 匹配一个以四位十六进制数（\u0000-\uFFFF）表示的unicode字符。
```

## 字符类

字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如`[xyz]` 表示`x`、`y`、`z`之中任选一个匹配。

```
/[abc]/.test('hello world') // false
/[abc]/.test('apple') // true
```

有两个字符在字符类中有特殊含义。

1. 脱字符(^)

   如果方括号内的第一个字符是`[^]`，则表示除了字符类之中的字符，其他字符都可以匹配。比如，`[^xyz]`表示除了`x`、`y`、`z`之外都可以匹配。

   ```
   /[^abc]/.test('hello world') // true
   /[^abc]/.test('bbc') // false
   ```

   如果方括号内没有其他字符，即只有`[^]`，就表示匹配一切字符，其中包括换行符，而点号（`.`）是不包括换行符的。

   ```
   var s = 'Please yes\nmake my day!';

   s.match(/yes.*day/) // null
   s.match(/yes[^]*day/) // [ 'yes\nmake my day']
   ```

   >注意，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。

2. 连字符(-)

   某些情况下，对于连续序列的字符，连字符（`-`）用来提供简写形式，表示字符的连续范围。比如，`[abc]`可以写成`[a-c]`，`[0123456789]`可以写成`[0-9]`，同理`[A-Z]`表示26个大写字母。

   ```
   /a-z/.test('b') // false
   /[a-z]/.test('b') // true
   ```

   ## 预定义模式

   预定义模式指的是某些常见模式的简写方式。

   ```
   \d 匹配0-9之间的任一数字，相当于[0-9]。
   \D 匹配所有0-9以外的字符，相当于[^0-9]。
   \w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。
   \W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。
   \s 匹配空格（包括换行符、制表符、空格符、断行符等），相等于[\t\r\n\v\f]。
   \S 匹配非空格的字符，相当于[^\t\r\n\v\f]。
   \b 匹配词的边界。
   \B 匹配非词边界，即在词的内部。
   ```

   ```
   // \s的例子
   /\s\w*/.exec('hello world') // [" world"]

   // \b的例子,\b表示词的边界，所以“world”的词首必须独立（词尾是否独立未指定），才会匹配。
   /\bworld/.test('hello world') // true
   /\bworld/.test('hello-world') // true
   /\bworld/.test('helloworld') // false

   // \B的例子
   /\Bworld/.test('hello-world') // false
   /\Bworld/.test('helloworld') // true
   ```

   ## 重复类

   模式的精确匹配次数，使用大括号（`{}`）表示。`{n}`表示恰好重复n次，`{n,}`表示至少重复n次，`{n,m}`表示重复不少于n次，不多于m次。

   ```
   /lo{2}k/.test('look') // true
   /lo{2, 5}k/.test('looook') // true
   ```

   ## 量词符

   量词符用来设定某个模式出现的次数。

   -  ? 问号表示某个模式出现0次或1次，等同于{0,1}
   - `*` 星号表示某个模式出现0次或多次，等同于{0,}
   -  +加号表示某个模式出现1次或多次，等同于{1,}

   ## 贪婪模式

   上面的三个量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。

   ```
   var s = 'aaa';
   s.match(/a+/) // ["aaa"]
   ```

   如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。

   ```
   var s = 'aaa';
   s.match(/a+?/) // ["a"]
   ```

   这时就改为非贪婪模式，一旦条件满足，就不再往下匹配。

   - `*?`：表示某个模式出现0次或多次，匹配时采用非贪婪模式。
   - `+?`：表示某个模式出现1次或多次，匹配时采用非贪婪模式。

   ## 修饰符

   修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。

   修饰符可以单个使用，也可以多个一起使用。

   ```
   // 单个修饰符
   var regex = /test/i;

   // 多个修饰符
   var regex = /test/ig;
   ```

   - g修饰符

   默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。`g`修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。

   - i修饰符

   默认情况下，正则对象区分字母的大小写，加上`i`修饰符以后表示忽略大小写（ignorecase）。

   - m修饰符

   `m`修饰符表示多行模式（multiline），会修改`^`和`$`的行为。默认情况下（即不加`m`修饰符时），`^`和`$`匹配字符串的开始处和结尾处，加上`m`修饰符以后，`^`和`$`还会匹配行首和行尾，即`^`和`$`会识别换行符（`\n`）

   ```
   /world$/.test('hello world\n') // false
   /world$/m.test('hello world\n') // true
   /^b/m.test('a\nb') // true
   ```

   ## 组匹配

   正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。

   ```
   /fred+/.test('fredd') // true
   /(fred)+/.test('fredfred') // true
   ```

   上面代码中，第一个模式没有括号，结果`+`只表示重复字母`d`，第二个模式有括号，结果`+`就表示匹配“fred”这个词。

   下面是另外一个分组捕获的例子。

   ```
   var m = 'abcabc'.match(/(.)b(.)/);
   m
   // ['abc', 'a', 'c']
   ```

   上面代码中，正则表达式`/(.)b(.)/`一共使用两个括号，第一个括号捕获`a`，第二个括号捕获`c`。

   注意，使用组匹配时，不宜同时使用`g`修饰符，否则`match`方法不会捕获分组的内容。

   ```
   var m = 'abcabc'.match(/(.)b(.)/g);
   m
   // ['abc', 'abc']
   ```

   上面代码使用带`g`修饰符的正则表达式，结果`match`方法只捕获了匹配整个表达式的部分。

   在正则表达式内部，可以用`\n`引用括号匹配的内容，`n`是从1开始的自然数，表示对应顺序的括号。

   ```
   /(.)b(.)\1b\2/.test("abcabc")
   // true
   ```

   上面的代码中，`\1`表示前一个括号匹配的内容（即“a”），`\2`表示第二个括号匹配的内容（即“b”）。

   下面是另外一个例子。

   ```
   /y(..)(.)\2\1/.test('yabccab') // true
   ```

   括号还可以嵌套。

   ```
   /y((..)\2)\1/.test('yabababab') // true
   ```

   上面代码中，`\1`指向外层括号，`\2`指向内层括号。

   组匹配非常有用，下面是一个匹配网页标签的例子。

   ```
   var tagName = /<([^>]+)>[^<]*<\/\1>/;

   tagName.exec("<b>bold</b>")[1]
   // 'b'
   ```

   ### 非捕获组

   `(?:x)`称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。

   非捕获组的作用请考虑这样一个场景，假定需要匹配`foo`或者`foofoo`，正则表达式就应该写成`/(foo){1, 2}/`，但是这样会占用一个组匹配。这时，就可以使用非捕获组，将正则表达式改为`/(?:foo){1, 2}/`，它的作用与前一个正则是一样的，但是不会单独输出括号内部的内容。

   ```
   var m = 'abc'.match(/(?:.)b(.)/);
   m // ["abc", "c"]
   ```

   下面是用来分解网址的正则表达式。

   ```
   // 正常匹配
   var url = /(http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/;

   url.exec('http://google.com/');
   // ["http://google.com/", "http", "google.com", "/"]

   // 非捕获组匹配
   var url = /(?:http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/;

   url.exec('http://google.com/');
   // ["http://google.com/", "google.com", "/"]
   ```

   ### 先行断言

   `x(?=y)`称为先行断言（Positive look-ahead），`x`只有在`y`前面才匹配，`y`不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成`/\d+(?=%)/`。

   “先行断言”中，括号里的部分是不会返回的。

   ```
   var m = 'abc'.match(/b(?=c)/);
   m // ["b"]
   ```

   ### 先行否定断言

   `x(?!y)`称为先行否定断言（Negative look-ahead），`x`只有不在`y`前面才匹配，`y`不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成`/\d+(?!%)/`。

   ```
   /\d+(?!\.)/.exec('3.14')
   // ["14"]
   ```

   上面代码中，正则表达式指定，只有不在小数点前面的数字才会被匹配，因此返回的结果就是`14`。

   “先行否定断言”中，括号里的部分是不会返回的。

