# 问题总结

产品、个人作品输出

阡陌金融  

> 浏览器兼容问题
>
> ```
> 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一
> IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大
> 浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。）如#box{ float:left; width:10px; margin:0 0 0 10px;};这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别)
> 渐进识别的方式，从总体中逐渐排除局部。
>   首先，巧妙的使用“\9”这一标记，将IE游览器从所有情况中分离出来。
>
>   接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。
>
>   css
>
>       .bb{
>
>        background-color:#f1ee18;/*所有识别*/
>
>       .background-color:#00deff\9; /*IE6、7、8识别*/
>
>       +background-color:#a200ff;/*IE6、7识别*/
>
>       _background-color:#1e0bd1;/*IE6识别*/
>
>       }
>
> 怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。现在可以使用[html5](http://www.w3.org/TR/html5/single-page.html)推荐的写法：`<doctype html>`
> ```
>
> 

康拓普  

> 性能优化
>
> ```
> 代码层面：避免使用css表达式，避免使用高级选择器，通配选择器。
> 缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等
> 请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载
> 请求带宽：压缩文件，开启GZIP
> 代码层面：
> 用hash-table来优化查找
>
> 少用全局变量
>
> 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能
>
> 用setTimeout来避免页面失去响应
>
> 缓存DOM节点查找的结果
>
> 避免使用CSS Expression
>
> 避免全局查询
>
> 避免使用with(with会创建自己的作用域，会增加作用域链长度)
>
> 多个变量声明合并
>
> 避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率
>
> 尽量避免写在HTML标签中写Style属性
>
> 移动端性能优化
>
> 尽量使用css3动画，开启硬件加速。
> 适当使用touch事件代替click事件。
> 避免使用css3渐变阴影效果。
> 可以用transform: translateZ(0)来开启硬件加速。
> 不滥用Float。Float在渲染时计算量比较大，尽量减少使用
> 不滥用Web字体。Web字体需要下载，解析，重绘当前页面，尽量减少使用。
> 合理使用requestAnimationFrame动画代替setTimeout
> CSS中的属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）会触发GPU渲染，请合理使用。过渡使用会引发手机过耗电增加
> PC端的在移动端同样适用
> ```
>
> 常见漏洞理解和相关实践
>
> ```
> sql注入原理
> 就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。
> XSS原理及防范
> Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意 html标签或者javascript代码
> 首先代码里对用户输入的地方和变量都需要仔细检查长度和对”<”,”>”,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来;避免直接在cookie 中泄露用户隐私，例如email、密码等等;通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险;如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上HttpOnly 来防止javascript 代码直接获取cookie;尽量采用POST 而非GET 提交表单
> CSRF原理和防御
> CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。
> 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数;通过验证码的方法
> ```

其他问题汇总

>jq的方法没有完全理解
>
>map方法结合[1,2,3,4,5,6].map(parseInt(2))输出为什么
>
>jq子元素获取父元素，添加绑定方法
>
>>用closest方法
>
>原型链的表述
>
>css box-sizing、position、display的理解，动画的理解；inline-block使用会遇到哪些问题，怎么解决
>
>- `absolute` :生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位。
>- `fixed` （老IE不支持）生成绝对定位的元素，通常相对于浏览器窗口或 frame 进行定位。
>- `relative` 生成相对定位的元素，相对于其在普通流中的位置进行定位。
>- `static` 默认值。没有定位，元素出现在正常的流中
>- `sticky` 生成粘性定位的元素，容器的位置根据正常文档流计算得出
>
>
>
>用一个方法获取所有匹配了相关class的元素绑定click事件
>
>ajax的写法，jq的ajax有哪些option，ajax有哪两个对象
>
>手机端touch事件的理解
>
>cmd、amd的理解
>
>> `AMD` 是提前执行，`CMD` 是延迟执行。
>>
>> `AMD`推荐的风格通过返回一个对象做为模块对象，`CommonJS`的风格通过对`module.exports`或`exports`的属性赋值来达到暴露模块对象的目的。
>
>promise
>
>> 解决回调地狱而设计
>>
>> `Promise` 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算。
>>
>> 四种状态
>>
>> pending：初始状态，非fulfilled或rejected
>>
>> fulfilled：成功的操作
>>
>> rejected：失败的操作
>>
>> settled：promise已被fulfilled或rejected，且不是pending
>
>vue的实现机制、mvvm的理解、虚拟dom的理解
>
>js继承的方法 有哪些
>
>>原型链继承（对象间）
>>
>>类式继承（构造函数间）
>
>meta的理解、如何设置页面缓存
>
>1.静态的html页面想要设置使用缓存：<meta http-equiv="expires" content="utc时刻"/>，目前我只明确该方法可行。如果设置了<meta http-equiv="cache-control" content="max-age=时间"/>并不起缓存作用。
>
>  2.动态页面使用缓存：在页面上使用<meta http-equiv="expires" content="utc时刻"/>和<meta http-equiv="cache-control" content="max-age=时间"/>并不使动态页面使用缓存，要在后台代码段Response.AddHeader("cache-control","max-age=时间（单位：秒）")或Response.Expires=时间（单位：分）来启用缓存。如果用Response.AddHeader("expires","utc时刻")来设置Expires的话，cache-control的优先级比expires高，就是说如果设置了cache-control，那么expires设置的值就被覆盖掉。如果是用Response.Expires设置的话就不受这个约束。
>
>localstorage、sessionstorage的理解
>
>浮动元素引起的问题和解决方法
>
>>```
>>问题 
>>（1）父元素的高度无法被撑开，影响与父元素同级的元素
>>（2）与浮动元素同级的非浮动元素（内联元素）会跟随其后
>>（3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构
>>解决方法
>>使用CSS中的clear:both;属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加clearfix样式：
>>.clearfix:after{content: ".";display: block;height: 0;clear: both;visibility: hidden;}
>>.clearfix{display: inline-block;} /* for IE/Mac */
>>清除浮动的几种方法：
>>1.额外标签法，<div style="clear:both;"></div>（缺点：不过这个办法会增加额外的标签使HTML结构看起来不够简洁。）
>>2.使用after伪类:
>>#parent:after {
>>  content: '';
>>  height: 0;
>>  visibility: hidden;
>>  display: block;
>>  clear: both;
>>}
>>3.浮动外部元素
>>4.设置overflow为hidden或者auto
>>```

支持h5新标签：

```
   IE8/IE7/IE6支持通过document.createElement方法产生的标签，

    可以利用这一特性让这些浏览器支持HTML5新标签，

    当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架

       <!--[if lt IE 9]>

       <script> src="http://html5shim.googlecode.com/svn/trunk/html5.js"</script>

       <![endif]-->

    如何区分： DOCTYPE声明\新增的结构元素\功能元素
```

列举IE与其他浏览器不一样的特性

- IE支持currentStyle，Firefox使用getComputeStyle
- IE使用innerText，ff使用textContent
- 滤镜方面：IE：filter:alpha(opacity= num), ff:-moz-opacity: num
- 事件方面：IE：attachEvent ff：addEventListener
- 鼠标位置：IE：event.clientX ff：event.pageX
- IE使用event.srcElement; ff使用event.target
- IE中消除list的原点仅需margin:0即可达到最终效果；FIrefox需要设置`margin:0;padding:0以及list-style:none`
- CSS圆角：ie7以下不支持圆角

严格模式主要有以下限制：

```
变量必须声明后再使用

函数的参数不能有同名属性，否则报错

不能使用with语句

不能对只读属性赋值，否则报错

不能使用前缀0表示八进制数，否则报错

不能删除不可删除的属性，否则报错

不能删除变量delete prop，会报错，只能删除属性delete global[prop]

eval不会在它的外层作用域引入变量

eval和arguments不能被重新赋值

arguments不会自动反映函数参数的变化

不能使用arguments.callee

不能使用arguments.caller

禁止this指向全局对象

不能使用fn.caller和fn.arguments获取函数调用的堆栈

增加了保留字（比如protected、static和interface）
```

面试题汇总

- 行内元素（a,span,br,b,img,input,label,textarea）与块级元素（div,form,fieldset,h1-h6,hr,ul,li,ol,p,table,tbody,tr,td,tfoot,thead,th）

三个区别：

1. 直观区别

   行内元素会在一条直线上排列，都是同一行的，水平方向排列

   块级元素各占据一行，垂直方向排列。块级元素从新行开始结束接着一个断行。

2. 块级元素可以包含行内元素和块级元素。行内元素不能包含块级元素。

3. 行内元素与块级元素属性的不同，主要是盒模型属性上。行内元素设置width无效，height无效(可以设置line-height)，margin上下无效，padding上下无效

空元素（<br/>）

- href和src的区别

  ```
  href 表示超文本引用（hypertext reference），在 link和a 等元素上使用。src 表示来源地址，在 img、script、iframe 等元素上。

  src 的内容，是页面必不可少的一部分，是引入。href 的内容，是与该页面有关联，是引用。区别就是，引入和引用
  ```

  ​

- px和em的区别

```
px表示像素 (计算机屏幕上的一个点：1px = 1/96in)，是绝对单位 ，不会因为其他元素的尺寸变化而变化。
em表示相对于父元素的字体大小。em是相对单位 ，没有一个固定的度量值，而是由其他元素尺寸来决定的相对值
```

- css选择符有哪些？哪些属性可以继承？优先级算法？

通配选择符，标签选择符，类选择器，id选择器，简单属性选择，具体属性选择，后代选择器，子元素选择器，相邻兄弟选择器，伪类选择器

