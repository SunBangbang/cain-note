## 浏览器与服务器通信过程

### TCP连接

浏览器与服务器三次握手，建立TCP连接

### 客户端请求

建立TCP连接后，客户端就会向服务器发送一个HTTP请求信息（比如请求HTML资源，暂且就把这个称为“HTML请求”）

### 服务器响应

服务器接收到请求后进行处理并发回一个HTTP响应信息

## HTTP/1.x简介

- 在HTTP1.0下，每完成一个请求和响应，TCP连接就会断开，因为TCP连接会有RTT（Round Trip Time,往返时间），每请求一个资源就要有一次RTT，所有需要加载资源比较多的网站会打开得很慢
- 在HTTP1.1下，TCP可以持久连接，一次TCP连接要等到同域名下的所有资源请求/相应完毕了连接才会断开，请求同域名下的n个资源就能节省（n-1）*RTT的时间

HTTP/1.1时请求一个HTML和一个CSS只需要经历一次TCP连接

![Http1.1请求](Http1.1请求.png)

HTTP1.0和HTTP1.1区别：

1. **缓存处理**，在HTTP1.0中主要使用header里的if-Modified-Since，Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略如Entity tag，If-Unmodified-Since，If-Match，If-None-Match等更多可供选择的缓存头来控制缓存策略
2. **带宽优化及网络连接的使用**，HTTP1.0中，存在一些浪费带宽的现象，如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，则返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
3. **错误通知的管理**，在HTTP1.1新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
4. **Host头处理**，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
5. **长连接**，HTTP1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection：keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。

#### HTTP/1.x现在存在的一些问题

- HTTP1.x在传输数据时，每次都需要重新建立连接，增加了大量的延迟时间
- HTTP1.x在传输数据时，所有的传输内容都是明文的，客户端和服务端无法验证对方的身份，在一定程度上无法保证数据的安全性
- HTTP1.x在使用时，header里携带的内容太大，增加了传输的成本，在移动端增加用户流量
- HTTP1.x虽然支持了keep-alive来减少多次创建连接产生的延迟，但是keep-alive使用多了会给服务器带来大量的性能压力，并且对于单个文件被不断请求的服务，因为文件被请求之后还保持了不必要的连接时间，keep-alive可能会极大的影响服务器的性能
- 虽然HTTP1.x可以让客户端向服务端并行发送多个请求，而且服务器也可以并行处理多个请求，但是HTTP1.x有严格的串行返回响应机制，通过TCP连接返回响应时，必须一个接一个，前一个响应没有完成，下一个响应就不能返回，如果第一个响应时间很长，那么后面的响应处理完了也无法发送，只能被缓存起来，占用服务器内存

## SPDY

为了解决http1.0和1.1存在的问题，Google在2012年提出了SPDY方案

该设计位于HTTP之下，TCP和SSL之上，兼容老版本，还可以使用已有的SSL功能。SPDY分为基础功能和高级功能，基础功能默认开启，高级功能手动开启。

####基础功能

- 多路复用（multiplexing）多路复用通过多个请求stream共享一个tcp连接方式。解决队头阻塞，降低了延迟提高带宽利用率
- 请求优先级（request prioritization）在多路复用的时候会出现关键请求被阻塞。SPDY允许每次request设置优先级
- header压缩。压缩率达到80%以上

#### 高级功能

- server推送（server push）开启server push之后，服务器通过X-Associated-Content header告知客户端有新内容推送过来
- server暗示（server hint）不推送，只提示有新内容

## HTTP/2

### 新特性

1. 二进制分帧层
2. 多向请求与响应
3. 优先级和依赖性
4. 首部压缩
5. 服务器推送

### 好处

1. 多路复用（MultiPlexing）：一次TCP握手，多个域名并行请求，请求和响应同时发送接收，然后再拼接组合，不阻塞；一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的id将request再归属到各自不同的服务端请求里面，原理图：

![多路复用](多路复用.png)

2. header压缩：HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减少了需要传输的大小
3. 优先级和依赖性（Priority）：可以请求的时候告知服务器端，资源分配权重，优先加载重要资源
4. 服务器推送（Server Push）：根据客户端需求，服务端主动推送资源，减少请求耗时

### header

#### cookie

cookie是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器下次向同一服务器再发起请求时被携带并发送到服务器上。它用于告知服务端两个请求是否来自同一浏览器，并保持用户的登录状态

服务器发送的响应报文包含set-cookie首部字段，客户端得到响应报文后把cookie内容保存到浏览器中

##### 分类

- 会话期Cookie：浏览器关闭之后会被自动删除，仅在会话期内有效
- 持久性Cookie：指定一个特定的过期时间（Expires）或有效期（Max-Age）之后就成为了持久性的Cookie

标记为Secure的Cookie只应通过被HTTPS协议加密过的请求发送给服务器。但即便设置了Secure标记，敏感信息也不应通过Cookie传输，因为Cookie有其固有的不安全性，Secure标记也无法提供确实的安全保障

标记为HttpOnly的Cookie不能被Js脚本调用。一定程度上避免XSS攻击

domain标识指定了哪些主机可以接受Cookie。不指定默认为当前文档的主机

##### 结合Session

可以利用session存储在服务器端。如内存型数据库redis

##### cookie和session选择

cookie只能存储ASCII码字符串，而Session则可以存取任何类型的数据，因此在考虑数据复杂性时首选session

cookie存储在浏览器中，容易被恶意查看

如果用户所有的信息都存储在Session中，那么开销非常大，不建议将所有的用户信息都存储到Session中

#### cache-control

1. 禁止进行缓存 no-store指令规定不能对请求或相应的任何一部分进行缓存
2. 强制确认缓存 no-cache指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效才将能使用该缓存对客户端的请求进行相应
3. 私有缓存 private指令规定将资源作为私有缓存，一般存储在用户浏览器中
4. 公共缓存 public指令将资源作为公共缓存，可以被多个用户所使用，一般存储在代理服务器中
5. 缓存过期机制 max-age